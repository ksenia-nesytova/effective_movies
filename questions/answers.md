>Как вы можете описать процесс распространения событий в
JavaScript (Event Propagation)? Расскажите о его основных фазах.
Какие есть способы применения знаний о фазах
распространения событий на практике?

**Event Propagataion** - порядок, согласно которому событие движется по DOM.

_**Event Propagataion**_ состоит из **3 основных фаз**:
* **Capturing** (Перехват) - событие проходит путь сверху DOM(порядок обычно примерно следующий: window > document > html > body > ... > target element) до цели(event target).
* **Target** - Момент, когда событие достигает цели(event target) (формально можно не выносить в отдельную фазу). 
* **Bubbling** (Всплытие) - событие двигает от event target к верху DOM(до window). Это дефолтное направление движения события. Здесь отрабатывают обработчики, назначенные на event target, и дальее событие движется вверх к родительским элементам. 

При регистрации обработчика можно выбрать направление движения события(в какой фазе оно будет выполнено: Перехват или Всплытие).

**Что со всем этим делать**
(примеры на Angular, принцип тот же)

Обработчик событий отрабатывает только в указанном контексте.
* Так, если мы полагаемся на Всплытие и хотим обработать одно и то же событие, например, click, для контейнера и его дочерних элементов, мы можем назначить обработчик только для родительского контейнера, и при клике на любой из дочерних элементов, событие "всплывет" до элемента, на которое назначен обработчик, и будет обработано корректно + таким образом уменьшим количество зарегистрированных обработчиков, что повысит производительность

```html
//При клике на любой из параграфов внутри section(event target), событие будет обработано обработчиком события родительского элемента. Поскольку мы передаем объект $event, то мы можем узнать, на который из параграфов нажали
<section (click)="doSomething($event)">
<p>Click me!</p>
<p>Or me!</p>
</section>
```

* Также Bubbling позволяет контролировать, на каком элементе событие остановится. Например, у нас есть карточка, нажатие на которую перенаправляет пользователя на другую страницу. Внутри этой карточки есть интерактивные элементы(dropdown, radio btn, etc). Чтобы пользователь мог взаимодействовать с подобными элементами без того, чтобы его перебрасывало на новую страницу, можно остановить распространение событий на интерактивном элементе(_event.stopPropagation()_)

* Возможен обратный случай, когда нам нужно перехватить событие до того, как запуститка отбработка события на event target. Например, можно кликать на любой элемент страницы, и будет произведено какое-то действие(например, вызов модального окна). 
```html
//Если при добавлении обработчика события добавить флаг _capture: true_, то мы можем остановить событие до того, как оно достигнет последнего параграфа
<section id="parent">
<p>Click me!</p>
<p>Or me!</p>

<p id="copiable" (click)="stopModals($event)">Copy me without seeing pop-ups</p>
</section>
```

```javascript
@ViewChild('parent', { static: true })
parent: ElementRef<HTMLElement>;

ngOnInit() {
// Обработчик клика с capture: true
  this.parent.nativeElement.addEventListener(
    'click',
    () => {
      this.openModal();
    },
    { capture: true }
  );
}

stopModals(event: Event) {
 // Остановили распространение события, клик по параграфу с id="copiable" не всплывет до родительского элемента и не вызовет модалку
  event.stopPropagation();
}
```


>Расскажите, что такое Promise в JavaScript, как он работает, какие
основные состояния у него бывают? Каким еще способом можно
обработать асинхронный код? Какую роль в асинхронности играет
событийный цикл (Event Loop)?

**_Promise _** - это объект, содержащий (будущий) результат асинхронно выполняемой операции.

У промиса есть три состояния:
* **Pending** (В процессе; не _fulfilled_ и не _rejected_)
* **Fulfilled** (Завершен успешно)
* **Rejected** (Произошла ошибка)

Промис может разрешиться(выйти из состояния _pending_) только одним из двух состояний(_fulfilled_ или _rejected_). После завершения промиса состояние не меняется.

**Как ещё обрабатывать асинхронный код**
* С помощью **callback**'ов. Т.е. асинхронная функция начинает выполняться, когда этот процесс завершается, мы вызываем другую функцию(наш callback)
```javascript
setTimeout(() => console.log("Time's up!"), 500); //callback здесь это console.log()
```
* С помощью **async** и **await**. По сути, это другой сопособ написания промисов. async функция всегда возращает промис.
```javascript
async function getMovies() {
    try {
        // это промис
        const movies = await fetch(url);
    } catch(e) {
        console.error(e);
    }
}
```

**Что там с Event Loop**
JS может выполнять только одну операцию на момент времени. _**Event Loop** это то, что позволяет выполнять асинхронные операции в JS._
Event Loop это бесконечный цикл, состоящий из ожидания операций для выполнения, распределения этих задач по очередям и выполнения этих задач.
Так, сначала выполняются все синхронные операции из call stack, затем начинают обрабатываться очереди асинхронных операций. Асинхронные операции могут быть с низким приоритетом(event handlers, setTimeout и пр.). Они попадают в _очередь макрозадач_. Или с высоким(_**обработчики промисов**_: .then, .catch), они попадают в _очередь микрозадач_. 
Поскольку промисы попадают в очередь микрозадач, т.е. приоритет у них выше, они выполняются до любых macrotask.


>Что такое ООП, и какие его ключевые принципы вы могли бы
описать? При объяснении приводите примеры. Максимально
подробно расскажите о том, как ООП реализовано в JavaScript.


>Опишите максимально детально, как браузер обрабатывает URL,
начиная с момента его ввода в адресную строку и заканчивая
отображением страницы. Какие технологии позволяют ускорить
процесс? Какие проблемы (безопасность, междоменное
взаимодействие) могут возникать в процессе?

1. Вводим URL в адресную строку браузера
2. Проверяется кэш браузера, потом кэш DNS-сервера; Если в кэше DNS есть нужный IP-адрес, то шаг 3 можно пропустить
3. Браузер обращается к ближайшему DNS серверу, с запросом преобразовать доменное имя в IP-адрес. Если DNS-сервер отвечает за необходимую доменную зону и знает нужный IP, то он возвращает ответ с IP-адресом; если нет - то возвращает адрес другого DNS-сервера, который обладает более точной информацией и т.д.
4. Между бразуером и сервером устанавливается TCP-соединение; если используется HTTPS, браузер и сервер договаривают об используемом способе шифрования(TLS handshake)
5. Браузер отправляет HTTP-запрос(в HTTP/1.1, HTTP/2 или HTTP/3) серверу
6. Сервер присылает ответ с кодом(200, 404 и т.д.), заголовками(content-type, char-set и т.д.) и телом сообщения(нужная нам HTML-страница)
7. Браузер парсит HTML и начинает строить DOM. Если в документе предусмотрены CSS или JS, то для их получения отправляются доп. запросы
8. Браузер парсит CSS, выстраивает CSSDOM; Здесь же одновременно может выполняться JS
9. DOM и CSSDOM объединяются в render tree. Вычисляются позиции и размеры элементов(layout). На этом моменте на экране начинает отрисовываться страница(paint).

#### Оптимизация:
* **Кэширование**: браузер сохраняет редко меняющиеся ресурсы(изображения, файлы стилей CSS, библиотеки JS) в кэш, что значительно сокращает время загрузки страницы
* **CDN**: можно поместить тяжелые редко меняющиеся (статические) ресурсы(изображения, документы и т.д.) на сервер, который будет географически находиться близко к конечным пользователям, что ускоряет доставку контента пользователю и снижает нагрузку на сервер
* **Lazy loading** изображений и JS-модулей, т.е. загружать их только когда они понадобятся(например, когда пользователь должен увидеть элемент, который использует определенное изображение). Это уменьшает время первоначальной загрузки страницы.
* **Минификация ресурсов** - удаление из файлов приложения ненужных элементов(комментариев, неиспользуемых переменных, сокращение названий переменных и т.п.). Это уменьшает размер файлов и ускоряет их парсинг браузером.
* **Preload/Prefecth** - _Preload_: сообщаем браузеру, какие ресурсы следует загрузить в первую очередь(основные стили, шрифты); _Prefetch_: сообщаем, что можно подгрузить позже
* **Service Workers** - позволяют управлять кэшированием для создания наиболее комфортного использования приложения в режиме офлайн


#### Проблемы:
* **Безопасность**: Если использовать незащищенные протоколы(HTTP и т.п.), то данные передаются в открытом виде, т.е. без шифрования, такие данные можно прочитать/изменить. здесь могут возникнуть проблемы XSS, CSRF. Эту проблему решает испоьзование протоколов защищенных(HTTPS и т.п.).
* **Целостность** передаваемых данных может быть нарушена при передаче через ненадежные сети(решается с помощью хэширования/цифрового подписания) 
* **CORS**: браузер может блокировать отправку запроса, если на сервере нет соответствующего заголовка; т.е. междоменный запрос не может быть выполнен без явного согласия сервера.
