>Как вы можете описать процесс распространения событий в
JavaScript (Event Propagation)? Расскажите о его основных фазах.
Какие есть способы применения знаний о фазах
распространения событий на практике?

**Event Propagataion** - порядок, согласно которому событие движется по DOM.

_**Event Propagataion**_ состоит из **3 основных фаз**:
* **Capturing** (Перехват) - событие проходит путь сверху DOM(порядок обычно примерно следующий: window > document > html > body > ... > target element) до цели(event target).
* **Target** - Момент, когда событие достигает цели(event target) (формально можно не выносить в отдельную фазу). 
* **Bubbling** (Всплытие) - событие двигает от event target к верху DOM(до window). Это дефолтное направление движения события. Здесь отрабатывают обработчики, назначенные на event target, и дальее событие движется вверх к родительским элементам. 

При регистрации обработчика можно выбрать направление движения события(в какой фазе оно будет выполнено: Перехват или Всплытие).

**Что со всем этим делать**
(примеры на Angular, принцип тот же)

Обработчик событий отрабатывает только в указанном контексте.
* Так, если мы полагаемся на Всплытие и хотим обработать одно и то же событие, например, click, для контейнера и его дочерних элементов, мы можем назначить обработчик только для родительского контейнера, и при клике на любой из дочерних элементов, событие "всплывет" до элемента, на которое назначен обработчик, и будет обработано корректно + таким образом уменьшим количество зарегистрированных обработчиков, что повысит производительность

```html
//При клике на любой из параграфов внутри section(event target), событие будет обработано обработчиком события родительского элемента. Поскольку мы передаем объект $event, то мы можем узнать, на который из параграфов нажали
<section (click)="doSomething($event)">
<p>Click me!</p>
<p>Or me!</p>
</section>
```

* Также Bubbling позволяет контролировать, на каком элементе событие остановится. Например, у нас есть карточка, нажатие на которую перенаправляет пользователя на другую страницу. Внутри этой карточки есть интерактивные элементы(dropdown, radio btn, etc). Чтобы пользователь мог взаимодействовать с подобными элементами без того, чтобы его перебрасывало на новую страницу, можно остановить распространение событий на интерактивном элементе(_event.stopPropagation()_)

* Возможен обратный случай, когда нам нужно перехватить событие до того, как запуститка отбработка события на event target. Например, можно кликать на любой элемент страницы, и будет произведено какое-то действие(например, вызов модального окна). 
```html
//Если при добавлении обработчика события добавить флаг _capture: true_, то мы можем остановить событие до того, как оно достигнет последнего параграфа
<section id="parent">
<p>Click me!</p>
<p>Or me!</p>

<p id="copiable" (click)="stopModals($event)">Copy me without seeing pop-ups</p>
</section>
```

```javascript
@ViewChild('parent', { static: true })
parent: ElementRef<HTMLElement>;

ngOnInit() {
// Обработчик клика с capture: true
  this.parent.nativeElement.addEventListener(
    'click',
    () => {
      this.openModal();
    },
    { capture: true }
  );
}

stopModals(event: Event) {
 // Остановили распространение события, клик по параграфу с id="copiable" не всплывет до родительского элемента и не вызовет модалку
  event.stopPropagation();
}
```


>Расскажите, что такое Promise в JavaScript, как он работает, какие
основные состояния у него бывают? Каким еще способом можно
обработать асинхронный код? Какую роль в асинхронности играет
событийный цикл (Event Loop)?

**_Promise _** - это объект, содержащий (будущий) результат асинхронно выполняемой операции.

У промиса есть три состояния:
* **Pending** (В процессе; не _fulfilled_ и не _rejected_)
* **Fulfilled** (Завершен успешно)
* **Rejected** (Произошла ошибка)

Промис может разрешиться(выйти из состояния _pending_) только одним из двух состояний(_fulfilled_ или _rejected_). После завершения промиса состояние не меняется.

**Как ещё обрабатывать асинхронный код**
* С помощью **callback**'ов. Т.е. асинхронная функция начинает выполняться, когда этот процесс завершается, мы вызываем другую функцию(наш callback)
```javascript
setTimeout(() => console.log("Time's up!"), 500); //callback здесь это console.log()
```
* С помощью **async** и **await**. По сути, это другой сопособ написания промисов. async функция всегда возращает промис.
```javascript
async function getMovies() {
    try {
        // это промис
        const movies = await fetch(url);
    } catch(e) {
        console.error(e);
    }
}
```

**Что там с Event Loop**
JS может выполнять только одну операцию на момент времени. _**Event Loop** это то, что позволяет выполнять асинхронные операции в JS._
Event Loop это бесконечный цикл, состоящий из ожидания операций для выполнения, распределения этих задач по очередям и выполнения этих задач.
Так, сначала выполняются все синхронные операции из call stack, затем начинают обрабатываться очереди асинхронных операций. Асинхронные операции могут быть с низким приоритетом(event handlers, setTimeout и пр.). Они попадают в _очередь макрозадач_. Или с высоким(_**обработчики промисов**_: .then, .catch), они попадают в _очередь микрозадач_. 
Поскольку промисы попадают в очередь микрозадач, т.е. приоритет у них выше, они выполняются до любых macrotask.


>Что такое ООП, и какие его ключевые принципы вы могли бы
описать? При объяснении приводите примеры. Максимально
подробно расскажите о том, как ООП реализовано в JavaScript.


>Опишите максимально детально, как браузер обрабатывает URL,
начиная с момента его ввода в адресную строку и заканчивая
отображением страницы. Какие технологии позволяют ускорить
процесс? Какие проблемы (безопасность, междоменное
взаимодействие) могут возникать в процессе?